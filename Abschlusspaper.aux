\relax 
\providecommand\hyper@newdestlabel[2]{}
\providecommand\HyperFirstAtBeginDocument{\AtBeginDocument}
\HyperFirstAtBeginDocument{\ifx\hyper@anchor\@undefined
\global\let\oldcontentsline\contentsline
\gdef\contentsline#1#2#3#4{\oldcontentsline{#1}{#2}{#3}}
\global\let\oldnewlabel\newlabel
\gdef\newlabel#1#2{\newlabelxx{#1}#2}
\gdef\newlabelxx#1#2#3#4#5#6{\oldnewlabel{#1}{{#2}{#3}}}
\AtEndDocument{\ifx\hyper@anchor\@undefined
\let\contentsline\oldcontentsline
\let\newlabel\oldnewlabel
\fi}
\fi}
\global\let\hyper@last\relax 
\gdef\HyperFirstAtBeginDocument#1{#1}
\providecommand\HyField@AuxAddToFields[1]{}
\providecommand\HyField@AuxAddToCoFields[2]{}
\citation{MSOC}
\citation{SOCF}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces Links: Testergebnisbild nach einem erfolgreichen Durchlauf der OGL-Methode aus der verwendeten Intel-Testszene. Rote Linien um Objekte stellen die Axis Aligned Bounding Box des jeweiligen Objekts dar. Rechts: Bild aller Objekte, die beim Occlusion Culling als verdeckt klassifiziert wurden und im linken Bild nicht gerendert wurden.}}{1}{figure.1}}
\newlabel{fig:teaser}{{1}{1}{Links: Testergebnisbild nach einem erfolgreichen Durchlauf der OGL-Methode aus der verwendeten Intel-Testszene. Rote Linien um Objekte stellen die Axis Aligned Bounding Box des jeweiligen Objekts dar. Rechts: Bild aller Objekte, die beim Occlusion Culling als verdeckt klassifiziert wurden und im linken Bild nicht gerendert wurden}{figure.1}{}}
\@writefile{toc}{\contentsline {section}{\numberline {1}Einleitung}{1}{section.1}}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces Prozessor berechnet parallel zum Rendering der Grafikkarte, welche Objekte in der n\active@dq  \dq@prtct{a}chsten Szene zu sehen sind.}}{1}{figure.2}}
\newlabel{fig:ablauf}{{2}{1}{Prozessor berechnet parallel zum Rendering der Grafikkarte, welche Objekte in der n"achsten Szene zu sehen sind}{figure.2}{}}
\citation{MSOC}
\citation{HiZ}
\citation{MSOC}
\citation{MSOC}
\citation{MSOC}
\citation{MSOC}
\citation{MSOC}
\citation{MSOC}
\citation{MSOC}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces Verwende gr\active@dq  \dq@prtct{o}{\ss }tenteils vorhandene Strukturen, um die verwendete Geometrie zu laden. Anschlie{\ss }end erfolgt das Culling durch die neue OGL-Culling-Methode. Zum Schluss wird die nicht gecullte Geometrie an das Framework zur\active@dq  \dq@prtct{u}ckgegeben, damit das Ergebnis gerendert wird.}}{2}{figure.3}}
\newlabel{fig:ablaufframework}{{3}{2}{Verwende gr"o{\ss }tenteils vorhandene Strukturen, um die verwendete Geometrie zu laden. Anschlie{\ss }end erfolgt das Culling durch die neue OGL-Culling-Methode. Zum Schluss wird die nicht gecullte Geometrie an das Framework zur"uckgegeben, damit das Ergebnis gerendert wird}{figure.3}{}}
\@writefile{toc}{\contentsline {section}{\numberline {2}Related Work}{2}{section.2}}
\@writefile{toc}{\contentsline {section}{\numberline {3}Software Occlusion Culling}{2}{section.3}}
\@writefile{lof}{\contentsline {figure}{\numberline {4}{\ignorespaces Links: Menge der Occluder ohne Occludees, die in dieser Kameraeinstellung zu sehen sind, vgl. Abb.\ \ref  {fig:teaser} linkes Bild. Rechts: Testszene ohne Occluder, es sind ausschlie{\ss }lich Occludees zu sehen, vgl. ebenfalls Abb.\ \ref  {fig:teaser}.}}{2}{figure.4}}
\newlabel{fig:objects}{{4}{2}{Links: Menge der Occluder ohne Occludees, die in dieser Kameraeinstellung zu sehen sind, vgl. Abb.\ \ref {fig:teaser} linkes Bild. Rechts: Testszene ohne Occluder, es sind ausschlie{\ss }lich Occludees zu sehen, vgl. ebenfalls Abb.\ \ref {fig:teaser}}{figure.4}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {5}{\ignorespaces SOC-Ablauf: Nach Laden der Occludermenge wird im ersten Schritt durch Rasterisieren der Occluder der Tiefenpuffer generiert. Im zweiten Schritt werden die Occlusion Queries gestartet, die durch Rasterisierung und Tiefentests bestimmen, welche Objekte der Occludee-Menge sichtbar sind und welche nicht. Die Ergebnismenge wird an den Renderer weitergeleitet.}}{2}{figure.5}}
\newlabel{fig:socablauf}{{5}{2}{SOC-Ablauf: Nach Laden der Occludermenge wird im ersten Schritt durch Rasterisieren der Occluder der Tiefenpuffer generiert. Im zweiten Schritt werden die Occlusion Queries gestartet, die durch Rasterisierung und Tiefentests bestimmen, welche Objekte der Occludee-Menge sichtbar sind und welche nicht. Die Ergebnismenge wird an den Renderer weitergeleitet}{figure.5}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.1}Frustum Culling}{2}{subsection.3.1}}
\citation{MSOC}
\citation{MSOC}
\@writefile{lof}{\contentsline {figure}{\numberline {6}{\ignorespaces Links: Testbild der Szene. Rechts: Der dazugeh\active@dq  \dq@prtct{o}rige Tiefenpuffer, der in jedem Frame einmal berechnet wird und sp\active@dq  \dq@prtct{a}ter f\active@dq  \dq@prtct{u}r die Tiefentests der Occlusion Queries verwendet wird.}}{3}{figure.6}}
\newlabel{fig:db}{{6}{3}{Links: Testbild der Szene. Rechts: Der dazugeh"orige Tiefenpuffer, der in jedem Frame einmal berechnet wird und sp"ater f"ur die Tiefentests der Occlusion Queries verwendet wird}{figure.6}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.2}Tiefenpuffer Rasterisierung}{3}{subsection.3.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.3}Occlusion Queries}{3}{subsection.3.3}}
\@writefile{toc}{\contentsline {section}{\numberline {4}Ergebnisse}{3}{section.4}}
\@writefile{lof}{\contentsline {figure}{\numberline {7}{\ignorespaces Links: Startposition der Kamerafahrt. Mitte: n\active@dq  \dq@prtct{a}hert sich in einem Kreisbogen der Br\active@dq  \dq@prtct{u}cke an. Rechts: Die Kamera verl\active@dq  \dq@prtct{a}sst die Szene in gleichem Bogen, wie sie sich angen\active@dq  \dq@prtct{a}hert hat.}}{3}{figure.7}}
\newlabel{fig:fahrt}{{7}{3}{Links: Startposition der Kamerafahrt. Mitte: n"ahert sich in einem Kreisbogen der Br"ucke an. Rechts: Die Kamera verl"asst die Szene in gleichem Bogen, wie sie sich angen"ahert hat}{figure.7}{}}
\bibstyle{abbrv}
\bibdata{literatur}
\bibcite{SOCF}{1}
\bibcite{HiZ}{2}
\bibcite{MSOC}{3}
\@writefile{lof}{\contentsline {figure}{\numberline {8}{\ignorespaces Im linken Diagramm ist die Prozentangabe der weggeworfenen Dreiecke mit den f\active@dq  \dq@prtct{u}nf verschiedenen Methoden des SOC-Frameworks, bei einer Aufl\active@dq  \dq@prtct{o}sung des Tiefenpuffers von 1920x1080, zu sehen. Im rechten Diagramm wird die Anzahl der weggeworfenen Dreiecke bei unserer OGL-Methode mit f\active@dq  \dq@prtct{u}nf verschiedenen Aufl\active@dq  \dq@prtct{o}sungen des Tiefenpuffers verglichen. Interessant zu beobachten ist der Verlauf f\active@dq  \dq@prtct{u}r die Aufl\active@dq  \dq@prtct{o}sung 2432x1440, da er im abfallenden Bereich ungef\active@dq  \dq@prtct{a}hr linear und nicht ann\active@dq  \dq@prtct{a}hernd quadratisch verl\active@dq  \dq@prtct{a}uft. Tabelle: Die Anzahl der Draw Calls ist bei 2432x1440 ebenfalls etwas au\active@dq  \dq@prtct{s}erhalbs des Musters, vergleiche zum Beispiel mit 640x360.}}{4}{figure.8}}
\newlabel{fig:resolution_culled}{{8}{4}{Im linken Diagramm ist die Prozentangabe der weggeworfenen Dreiecke mit den f"unf verschiedenen Methoden des SOC-Frameworks, bei einer Aufl"osung des Tiefenpuffers von 1920x1080, zu sehen. Im rechten Diagramm wird die Anzahl der weggeworfenen Dreiecke bei unserer OGL-Methode mit f"unf verschiedenen Aufl"osungen des Tiefenpuffers verglichen. Interessant zu beobachten ist der Verlauf f"ur die Aufl"osung 2432x1440, da er im abfallenden Bereich ungef"ahr linear und nicht ann"ahernd quadratisch verl"auft. Tabelle: Die Anzahl der Draw Calls ist bei 2432x1440 ebenfalls etwas au"serhalbs des Musters, vergleiche zum Beispiel mit 640x360}{figure.8}{}}
\@writefile{toc}{\contentsline {section}{\numberline {5}Fazit}{4}{section.5}}
\@writefile{toc}{\contentsline {section}{\numberline {6}Future Work}{4}{section.6}}
\@writefile{lof}{\contentsline {figure}{\numberline {9}{\ignorespaces Vergleich Anzahl Draw Calls von Multi-Threading (MT), MT + Frustum Culling (FC) und MT + FC + Depth Test Culling (DTC). Anzahl Draw Calls geht mit Verlauf der Kamerafahrt mit FC und DTC deutlich runter. Ist DTC aktiviert, werden sind die Maximalwerte am Anfang und Schluss deutlich niedriger. !!! VERLGEICH MIT MOC !!!}}{5}{figure.9}}
\newlabel{fig:OGL_MOC_frustum_culling}{{9}{5}{Vergleich Anzahl Draw Calls von Multi-Threading (MT), MT + Frustum Culling (FC) und MT + FC + Depth Test Culling (DTC). Anzahl Draw Calls geht mit Verlauf der Kamerafahrt mit FC und DTC deutlich runter. Ist DTC aktiviert, werden sind die Maximalwerte am Anfang und Schluss deutlich niedriger. !!! VERLGEICH MIT MOC !!!}{figure.9}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {10}{\ignorespaces Im linken Diagramm die FPS der f\active@dq  \dq@prtct{u}nf verschiedenen Methoden, bei einer Aufl\active@dq  \dq@prtct{o}sung des Tiefenbuffers von 1920x1080, zu sehen. Im rechten Diagramm wird die Anzahl der FPS bei unserer OGL Methode mit f\active@dq  \dq@prtct{u}nf verschiedenen Aufl\active@dq  \dq@prtct{o}sungen des Tiefenbuffers verglichen.}}{5}{figure.10}}
\newlabel{fig:resolution_fps}{{10}{5}{Im linken Diagramm die FPS der f"unf verschiedenen Methoden, bei einer Aufl"osung des Tiefenbuffers von 1920x1080, zu sehen. Im rechten Diagramm wird die Anzahl der FPS bei unserer OGL Methode mit f"unf verschiedenen Aufl"osungen des Tiefenbuffers verglichen}{figure.10}{}}
