\relax 
\providecommand\hyper@newdestlabel[2]{}
\providecommand\HyperFirstAtBeginDocument{\AtBeginDocument}
\HyperFirstAtBeginDocument{\ifx\hyper@anchor\@undefined
\global\let\oldcontentsline\contentsline
\gdef\contentsline#1#2#3#4{\oldcontentsline{#1}{#2}{#3}}
\global\let\oldnewlabel\newlabel
\gdef\newlabel#1#2{\newlabelxx{#1}#2}
\gdef\newlabelxx#1#2#3#4#5#6{\oldnewlabel{#1}{{#2}{#3}}}
\AtEndDocument{\ifx\hyper@anchor\@undefined
\let\contentsline\oldcontentsline
\let\newlabel\oldnewlabel
\fi}
\fi}
\global\let\hyper@last\relax 
\gdef\HyperFirstAtBeginDocument#1{#1}
\providecommand\HyField@AuxAddToFields[1]{}
\providecommand\HyField@AuxAddToCoFields[2]{}
\citation{MSOC}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces Links: Testergebnisbild nach einem erfolgreichen Durchlauf der OGL-Methode aus der verwendeten Intel-Testszene. Rote Linien um Objekte stellen die Axis Aligned Bounding Box des jeweiligen Objekts dar. Rechts: Bild aller Objekte, die beim Occlusion Culling als verdeckt klassifiziert wurden und im linken Bild nicht gerendert wurden.}}{1}{figure.1}\protected@file@percent }
\newlabel{fig:teaser}{{1}{1}{Links: Testergebnisbild nach einem erfolgreichen Durchlauf der OGL-Methode aus der verwendeten Intel-Testszene. Rote Linien um Objekte stellen die Axis Aligned Bounding Box des jeweiligen Objekts dar. Rechts: Bild aller Objekte, die beim Occlusion Culling als verdeckt klassifiziert wurden und im linken Bild nicht gerendert wurden}{figure.1}{}}
\@writefile{toc}{\contentsline {section}{\numberline {1}Einleitung}{1}{section.1}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces W\active@dq  \dq@prtct{a}hrend ein Frame gerendert wird, berechnet der Prozessor parallel zum Rendering bereits, welche Objekte in der n\active@dq  \dq@prtct{a}chsten Szene zu sehen sind.}}{1}{figure.2}\protected@file@percent }
\newlabel{fig:ablauf}{{2}{1}{W"ahrend ein Frame gerendert wird, berechnet der Prozessor parallel zum Rendering bereits, welche Objekte in der n"achsten Szene zu sehen sind}{figure.2}{}}
\citation{SOCF}
\citation{MSOC}
\citation{HiZ}
\citation{MSOC}
\citation{MSOC}
\citation{MSOC}
\citation{MSOC}
\citation{MSOC}
\citation{MSOC}
\citation{MSOC}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces Verwende gr\active@dq  \dq@prtct{o}{\ss }tenteils vorhandene Strukturen, um die verwendete Geometrie zu laden. Anschlie{\ss }end erfolgt das Culling durch die neue OGL-Culling-Methode. Zum Schluss wird die nicht gecullte Geometrie an das Framework zur\active@dq  \dq@prtct{u}ckgegeben, damit das Ergebnis gerendert wird.}}{2}{figure.3}\protected@file@percent }
\newlabel{fig:ablaufframework}{{3}{2}{Verwende gr"o{\ss }tenteils vorhandene Strukturen, um die verwendete Geometrie zu laden. Anschlie{\ss }end erfolgt das Culling durch die neue OGL-Culling-Methode. Zum Schluss wird die nicht gecullte Geometrie an das Framework zur"uckgegeben, damit das Ergebnis gerendert wird}{figure.3}{}}
\@writefile{toc}{\contentsline {section}{\numberline {2}Related Work}{2}{section.2}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {4}{\ignorespaces Links: Menge der Occluder ohne Occludees, die in dieser Kameraeinstellung zu sehen sind, vgl. Abb.\ \ref  {fig:teaser} linkes Bild. Rechts: Testszene ohne Occluder, es sind ausschlie{\ss }lich Occludees zu sehen, vgl. ebenfalls Abb.\ \ref  {fig:teaser}.}}{2}{figure.4}\protected@file@percent }
\newlabel{fig:objects}{{4}{2}{Links: Menge der Occluder ohne Occludees, die in dieser Kameraeinstellung zu sehen sind, vgl. Abb.\ \ref {fig:teaser} linkes Bild. Rechts: Testszene ohne Occluder, es sind ausschlie{\ss }lich Occludees zu sehen, vgl. ebenfalls Abb.\ \ref {fig:teaser}}{figure.4}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {5}{\ignorespaces SOC-Ablauf: Nach Laden der Occludermenge wird im ersten Schritt durch Rasterisieren der Occluder der Tiefenpuffer generiert. Im zweiten Schritt werden die Occlusion Queries gestartet, die durch Rasterisierung und Tiefentests bestimmen, welche Objekte der Occludee-Menge sichtbar sind und welche nicht. Die Ergebnismenge wird an den Renderer weitergeleitet.}}{2}{figure.5}\protected@file@percent }
\newlabel{fig:socablauf}{{5}{2}{SOC-Ablauf: Nach Laden der Occludermenge wird im ersten Schritt durch Rasterisieren der Occluder der Tiefenpuffer generiert. Im zweiten Schritt werden die Occlusion Queries gestartet, die durch Rasterisierung und Tiefentests bestimmen, welche Objekte der Occludee-Menge sichtbar sind und welche nicht. Die Ergebnismenge wird an den Renderer weitergeleitet}{figure.5}{}}
\@writefile{toc}{\contentsline {section}{\numberline {3}Software Occlusion Culling}{2}{section.3}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {3.1}Frustum Culling}{2}{subsection.3.1}\protected@file@percent }
\citation{MSOC}
\citation{MSOC}
\@writefile{lof}{\contentsline {figure}{\numberline {6}{\ignorespaces Links: Testbild der Szene. Rechts: Der dazugeh\active@dq  \dq@prtct{o}rige Tiefenpuffer, der in jedem Frame einmal berechnet wird und sp\active@dq  \dq@prtct{a}ter f\active@dq  \dq@prtct{u}r die Tiefentests der Occlusion Queries verwendet wird. Der schwarze Balken unterhalb des Tiefenpuffers entsteht durch die Differenz zwischen Fensteraufl\active@dq  \dq@prtct{o}sung 1920x1200 und Tiefenpuffer-Aufl\active@dq  \dq@prtct{o}sung 1920x1080.}}{3}{figure.6}\protected@file@percent }
\newlabel{fig:db}{{6}{3}{Links: Testbild der Szene. Rechts: Der dazugeh"orige Tiefenpuffer, der in jedem Frame einmal berechnet wird und sp"ater f"ur die Tiefentests der Occlusion Queries verwendet wird. Der schwarze Balken unterhalb des Tiefenpuffers entsteht durch die Differenz zwischen Fensteraufl"osung 1920x1200 und Tiefenpuffer-Aufl"osung 1920x1080}{figure.6}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.2}Tiefenpuffer Rasterisierung}{3}{subsection.3.2}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {3.3}Occlusion Queries}{3}{subsection.3.3}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {4}Ergebnisse}{3}{section.4}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {7}{\ignorespaces Links: Startposition der Kamerafahrt. Mitte: n\active@dq  \dq@prtct{a}hert sich in einem Kreisbogen der Br\active@dq  \dq@prtct{u}cke an. Rechts: Die Kamera verl\active@dq  \dq@prtct{a}sst die Szene in gleichem Bogen, wie sie sich angen\active@dq  \dq@prtct{a}hert hat.}}{3}{figure.7}\protected@file@percent }
\newlabel{fig:fahrt}{{7}{3}{Links: Startposition der Kamerafahrt. Mitte: n"ahert sich in einem Kreisbogen der Br"ucke an. Rechts: Die Kamera verl"asst die Szene in gleichem Bogen, wie sie sich angen"ahert hat}{figure.7}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {8}{\ignorespaces Im linken Diagramm ist die Prozentangabe der weggeworfenen Dreiecke mit den f\active@dq  \dq@prtct{u}nf verschiedenen Methoden des SOC-Frameworks, bei einer Aufl\active@dq  \dq@prtct{o}sung des Tiefenpuffers von 1920x1080, zu sehen. Im rechten Diagramm wird die Anzahl der weggeworfenen Dreiecke bei unserer OGL-Methode mit f\active@dq  \dq@prtct{u}nf verschiedenen Aufl\active@dq  \dq@prtct{o}sungen des Tiefenpuffers verglichen. Interessant zu beobachten ist der Verlauf f\active@dq  \dq@prtct{u}r die Aufl\active@dq  \dq@prtct{o}sung 2432x1440, da er im abfallenden Bereich ungef\active@dq  \dq@prtct{a}hr linear und nicht ann\active@dq  \dq@prtct{a}hernd quadratisch verl\active@dq  \dq@prtct{a}uft. Tabelle: Die Anzahl der Draw Calls ist bei 2432x1440 ebenfalls etwas au\active@dq  \dq@prtct{s}erhalbs des Musters, vergleiche zum Beispiel mit 640x360.}}{4}{figure.8}\protected@file@percent }
\newlabel{fig:resolution_culled}{{8}{4}{Im linken Diagramm ist die Prozentangabe der weggeworfenen Dreiecke mit den f"unf verschiedenen Methoden des SOC-Frameworks, bei einer Aufl"osung des Tiefenpuffers von 1920x1080, zu sehen. Im rechten Diagramm wird die Anzahl der weggeworfenen Dreiecke bei unserer OGL-Methode mit f"unf verschiedenen Aufl"osungen des Tiefenpuffers verglichen. Interessant zu beobachten ist der Verlauf f"ur die Aufl"osung 2432x1440, da er im abfallenden Bereich ungef"ahr linear und nicht ann"ahernd quadratisch verl"auft. Tabelle: Die Anzahl der Draw Calls ist bei 2432x1440 ebenfalls etwas au"serhalbs des Musters, vergleiche zum Beispiel mit 640x360}{figure.8}{}}
\@writefile{toc}{\contentsline {paragraph}{Anmerkung}{4}{section*.2}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{Probleme}{4}{section*.3}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {5}Fazit}{4}{section.5}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {9}{\ignorespaces Vergleich Anzahl Draw Calls von Multi-Threading (MT), MT + Frustum Culling (FC) und MT + FC + Tiefentest Culling (TTC). Anzahl Draw Calls geht mit Verlauf der Kamerafahrt mit FC und TTC deutlich runter. Ist TTC aktiviert, werden sind die Maximalwerte am Anfang und Schluss deutlich niedriger. \textbf  {Vergleich mit MOC fehlt noch}}}{5}{figure.9}\protected@file@percent }
\newlabel{fig:OGL_MOC_frustum_culling}{{9}{5}{Vergleich Anzahl Draw Calls von Multi-Threading (MT), MT + Frustum Culling (FC) und MT + FC + Tiefentest Culling (TTC). Anzahl Draw Calls geht mit Verlauf der Kamerafahrt mit FC und TTC deutlich runter. Ist TTC aktiviert, werden sind die Maximalwerte am Anfang und Schluss deutlich niedriger. \textbf {Vergleich mit MOC fehlt noch}}{figure.9}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {10}{\ignorespaces Links: FPS-Vergleich aller SOC-Methoden im Intel-Framework bei Full-HD Aufl\active@dq  \dq@prtct{o}sung, aktiviertem MT, FC und TTC. OGL schneidet mit teilweise circa nur einem F\active@dq  \dq@prtct{u}nftel der FPS von MOC oder SSE deutlich am schlechtesten ab. Rechts: Kamerafahrt mit unterschiedlichen Tiefenpuffergr\active@dq  \dq@prtct{o}\active@dq  \dq@prtct{s}en. Mit niedriger werdenden Aufl\active@dq  \dq@prtct{o}sungen sinken die Tiefentestzeiten ab (siehe Tabelle) und die FPS steigen erwartungsgem\active@dq  \dq@prtct{a}\active@dq  \dq@prtct{s} an, mit einer Ausnahme bei der 4k-Aufl\active@dq  \dq@prtct{o}sung, die trotz ihrer 4-fachen Full-HD Puffergr\active@dq  \dq@prtct{o}\active@dq  \dq@prtct{s}e, besser abschneidet als die Full-HD Aufl\active@dq  \dq@prtct{o}sung.}}{5}{figure.10}\protected@file@percent }
\newlabel{fig:resolution_fps}{{10}{5}{Links: FPS-Vergleich aller SOC-Methoden im Intel-Framework bei Full-HD Aufl"osung, aktiviertem MT, FC und TTC. OGL schneidet mit teilweise circa nur einem F"unftel der FPS von MOC oder SSE deutlich am schlechtesten ab. Rechts: Kamerafahrt mit unterschiedlichen Tiefenpuffergr"o"sen. Mit niedriger werdenden Aufl"osungen sinken die Tiefentestzeiten ab (siehe Tabelle) und die FPS steigen erwartungsgem"a"s an, mit einer Ausnahme bei der 4k-Aufl"osung, die trotz ihrer 4-fachen Full-HD Puffergr"o"se, besser abschneidet als die Full-HD Aufl"osung}{figure.10}{}}
\bibstyle{abbrv}
\bibdata{literatur}
\bibcite{SOCF}{1}
\bibcite{HiZ}{2}
\bibcite{MSOC}{3}
\@writefile{toc}{\contentsline {paragraph}{Future Work}{6}{section*.4}\protected@file@percent }
