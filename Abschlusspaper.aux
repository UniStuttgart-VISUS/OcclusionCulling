\relax 
\providecommand\hyper@newdestlabel[2]{}
\providecommand\HyperFirstAtBeginDocument{\AtBeginDocument}
\HyperFirstAtBeginDocument{\ifx\hyper@anchor\@undefined
\global\let\oldcontentsline\contentsline
\gdef\contentsline#1#2#3#4{\oldcontentsline{#1}{#2}{#3}}
\global\let\oldnewlabel\newlabel
\gdef\newlabel#1#2{\newlabelxx{#1}#2}
\gdef\newlabelxx#1#2#3#4#5#6{\oldnewlabel{#1}{{#2}{#3}}}
\AtEndDocument{\ifx\hyper@anchor\@undefined
\let\contentsline\oldcontentsline
\let\newlabel\oldnewlabel
\fi}
\fi}
\global\let\hyper@last\relax 
\gdef\HyperFirstAtBeginDocument#1{#1}
\providecommand\HyField@AuxAddToFields[1]{}
\providecommand\HyField@AuxAddToCoFields[2]{}
\citation{MSOC}
\citation{PVS}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces Links: Testergebnisbild nach einem erfolgreichen Durchlauf der OOC-Methode aus der verwendeten Intel-Testszene. Rote Linien um Objekte stellen die Axis Aligned Bounding Box des jeweiligen Objekts dar. Rechts: Bild aller Objekte, die beim Occlusion Culling als verdeckt klassifiziert wurden und im linken Bild nicht gerendert wurden.}}{1}{figure.1}\protected@file@percent }
\newlabel{fig:teaser}{{1}{1}{Links: Testergebnisbild nach einem erfolgreichen Durchlauf der OOC-Methode aus der verwendeten Intel-Testszene. Rote Linien um Objekte stellen die Axis Aligned Bounding Box des jeweiligen Objekts dar. Rechts: Bild aller Objekte, die beim Occlusion Culling als verdeckt klassifiziert wurden und im linken Bild nicht gerendert wurden}{figure.1}{}}
\@writefile{toc}{\contentsline {section}{\numberline {1}Einleitung}{1}{section.1}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces W\active@dq  \dq@prtct{a}hrend ein Frame gerendert wird, berechnet der Prozessor parallel zum Rendering bereits, welche Objekte im n\active@dq  \dq@prtct{a}chsten Frame zu sehen sind.}}{1}{figure.2}\protected@file@percent }
\newlabel{fig:ablauf}{{2}{1}{W"ahrend ein Frame gerendert wird, berechnet der Prozessor parallel zum Rendering bereits, welche Objekte im n"achsten Frame zu sehen sind}{figure.2}{}}
\citation{SOCF}
\citation{MSOC}
\citation{HiZ}
\citation{MSOC}
\citation{MSOC}
\citation{MSOC}
\citation{MSOC}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces Verwende gr\active@dq  \dq@prtct{o}{\ss }tenteils vorhandene Strukturen, um die verwendete Geometrie zu laden. Anschlie{\ss }end erfolgt das Culling durch die neue OOC-Culling-Methode. Zum Schluss wird die nicht gecullte Geometrie an das Framework zur\active@dq  \dq@prtct{u}ckgegeben, damit das Ergebnis gerendert wird.}}{2}{figure.3}\protected@file@percent }
\newlabel{fig:ablaufframework}{{3}{2}{Verwende gr"o{\ss }tenteils vorhandene Strukturen, um die verwendete Geometrie zu laden. Anschlie{\ss }end erfolgt das Culling durch die neue OOC-Culling-Methode. Zum Schluss wird die nicht gecullte Geometrie an das Framework zur"uckgegeben, damit das Ergebnis gerendert wird}{figure.3}{}}
\@writefile{toc}{\contentsline {section}{\numberline {2}Related Work}{2}{section.2}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {4}{\ignorespaces Links: Menge der Occluder ohne Occludees, die in dieser Kameraeinstellung zu sehen sind, vgl. Abb.\ \ref  {fig:teaser} linkes Bild. Rechts: Testszene ohne Occluder, es sind ausschlie{\ss }lich Occludees zu sehen, vgl. ebenfalls Abb.\ \ref  {fig:teaser}.}}{2}{figure.4}\protected@file@percent }
\newlabel{fig:objects}{{4}{2}{Links: Menge der Occluder ohne Occludees, die in dieser Kameraeinstellung zu sehen sind, vgl. Abb.\ \ref {fig:teaser} linkes Bild. Rechts: Testszene ohne Occluder, es sind ausschlie{\ss }lich Occludees zu sehen, vgl. ebenfalls Abb.\ \ref {fig:teaser}}{figure.4}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {5}{\ignorespaces SOC-Ablauf: Nach Laden der Occludermenge wird im ersten Schritt durch Rasterisieren der Occluder der Tiefenpuffer generiert. Im zweiten Schritt werden die Occlusion Queries gestartet, die durch Rasterisierung und Tiefentests bestimmen, welche Objekte der Occludee-Menge sichtbar sind und welche nicht. Die Ergebnismenge wird an den Renderer weitergeleitet.}}{2}{figure.5}\protected@file@percent }
\newlabel{fig:socablauf}{{5}{2}{SOC-Ablauf: Nach Laden der Occludermenge wird im ersten Schritt durch Rasterisieren der Occluder der Tiefenpuffer generiert. Im zweiten Schritt werden die Occlusion Queries gestartet, die durch Rasterisierung und Tiefentests bestimmen, welche Objekte der Occludee-Menge sichtbar sind und welche nicht. Die Ergebnismenge wird an den Renderer weitergeleitet}{figure.5}{}}
\@writefile{toc}{\contentsline {section}{\numberline {3}(Software) Occlusion Culling}{2}{section.3}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {6}{\ignorespaces Im linken Diagramm ist die Prozentangabe der verworfenen Dreiecke mit den f\active@dq  \dq@prtct{u}nf verschiedenen Methoden des SOC-Frameworks bei einer Aufl\active@dq  \dq@prtct{o}sung des Tiefenpuffers von 1920x1080 zu sehen. Im rechten Diagramm wird die Anzahl der verworfenen Dreiecke der OOC-Methode mit f\active@dq  \dq@prtct{u}nf verschiedenen Aufl\active@dq  \dq@prtct{o}sungen des Tiefenpuffers verglichen. Interessant zu beobachten ist der Verlauf f\active@dq  \dq@prtct{u}r die Aufl\active@dq  \dq@prtct{o}sung 1920x1080, da er im abfallenden Bereich ungef\active@dq  \dq@prtct{a}hr linear und nicht ann\active@dq  \dq@prtct{a}hernd wie ${\begingroup 1\endgroup \over x}$ verl\active@dq  \dq@prtct{a}uft. Tabelle: Die gezeigten Werte sind jeweils Mittelwerte \active@dq  \dq@prtct{u}ber die gesamte Kamerafahrt. Die Anzahl der Draw Calls ist bei 1920x1080 ebenfalls etwas au\active@dq  \dq@prtct{s}erhalbs des Musters, vergleiche zum Beispiel mit 640x360.}}{3}{figure.6}\protected@file@percent }
\newlabel{fig:resolution_culled}{{6}{3}{Im linken Diagramm ist die Prozentangabe der verworfenen Dreiecke mit den f"unf verschiedenen Methoden des SOC-Frameworks bei einer Aufl"osung des Tiefenpuffers von 1920x1080 zu sehen. Im rechten Diagramm wird die Anzahl der verworfenen Dreiecke der OOC-Methode mit f"unf verschiedenen Aufl"osungen des Tiefenpuffers verglichen. Interessant zu beobachten ist der Verlauf f"ur die Aufl"osung 1920x1080, da er im abfallenden Bereich ungef"ahr linear und nicht ann"ahernd wie $\frac {1}{x}$ verl"auft. Tabelle: Die gezeigten Werte sind jeweils Mittelwerte "uber die gesamte Kamerafahrt. Die Anzahl der Draw Calls ist bei 1920x1080 ebenfalls etwas au"serhalbs des Musters, vergleiche zum Beispiel mit 640x360}{figure.6}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.1}Frustum Culling}{3}{subsection.3.1}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {3.2}Tiefenpuffer-Rasterisierung}{3}{subsection.3.2}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {7}{\ignorespaces Links: Testbild der Szene. Rechts: Der dazugeh\active@dq  \dq@prtct{o}rige Tiefenpuffer, der in jedem Frame einmal berechnet wird und sp\active@dq  \dq@prtct{a}ter f\active@dq  \dq@prtct{u}r die Tiefentests der Occlusion Queries verwendet wird. Der schwarze Balken unterhalb des Tiefenpuffers entsteht durch die Differenz zwischen Fensteraufl\active@dq  \dq@prtct{o}sung 1920x1200 und Tiefenpuffer-Aufl\active@dq  \dq@prtct{o}sung 1920x1080.}}{3}{figure.7}\protected@file@percent }
\newlabel{fig:db}{{7}{3}{Links: Testbild der Szene. Rechts: Der dazugeh"orige Tiefenpuffer, der in jedem Frame einmal berechnet wird und sp"ater f"ur die Tiefentests der Occlusion Queries verwendet wird. Der schwarze Balken unterhalb des Tiefenpuffers entsteht durch die Differenz zwischen Fensteraufl"osung 1920x1200 und Tiefenpuffer-Aufl"osung 1920x1080}{figure.7}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.3}Occlusion Queries}{3}{subsection.3.3}\protected@file@percent }
\citation{SOCF}
\citation{MSOC}
\@writefile{lof}{\contentsline {figure}{\numberline {8}{\ignorespaces Vergleich Anzahl Draw Calls von Multi-Threading (MT), MT + Frustum Culling (FC) und MT + FC + Occlusion Culling (OC). Anzahl Draw Calls geht mit Verlauf der Kamerafahrt mit FC und OC deutlich runter. Ist OC aktiviert, sind die Maximalwerte am Anfang und Schluss deutlich niedriger und durch die Konservativit\active@dq  \dq@prtct{a}t sind die Werte seitens des MOC h\active@dq  \dq@prtct{o}her als bei OOC.}}{4}{figure.8}\protected@file@percent }
\newlabel{fig:OGL_MOC_frustum_culling}{{8}{4}{Vergleich Anzahl Draw Calls von Multi-Threading (MT), MT + Frustum Culling (FC) und MT + FC + Occlusion Culling (OC). Anzahl Draw Calls geht mit Verlauf der Kamerafahrt mit FC und OC deutlich runter. Ist OC aktiviert, sind die Maximalwerte am Anfang und Schluss deutlich niedriger und durch die Konservativit"at sind die Werte seitens des MOC h"oher als bei OOC}{figure.8}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {9}{\ignorespaces Links: Startposition der Kamerafahrt. Mitte: n\active@dq  \dq@prtct{a}hert sich in einem Kreisbogen der Br\active@dq  \dq@prtct{u}cke an. Rechts: Die Kamera verl\active@dq  \dq@prtct{a}sst die Szene in gleichem Bogen, wie sie sich angen\active@dq  \dq@prtct{a}hert hat.}}{4}{figure.9}\protected@file@percent }
\newlabel{fig:fahrt}{{9}{4}{Links: Startposition der Kamerafahrt. Mitte: n"ahert sich in einem Kreisbogen der Br"ucke an. Rechts: Die Kamera verl"asst die Szene in gleichem Bogen, wie sie sich angen"ahert hat}{figure.9}{}}
\@writefile{toc}{\contentsline {section}{\numberline {4}Ergebnisse}{4}{section.4}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {10}{\ignorespaces Links: FPS-Vergleich aller SOC-Methoden im Intel-Framework bei Full-HD Aufl\active@dq  \dq@prtct{o}sung, aktiviertem MT, FC und TTC. OOC schneidet mit nur einem Bruchteil der FPS von MOC oder SSE deutlich am schlechtesten ab. Rechts: Kamerafahrt mit unterschiedlichen Tiefenpuffergr\active@dq  \dq@prtct{o}\active@dq  \dq@prtct{s}en. Mit niedriger werdenden Aufl\active@dq  \dq@prtct{o}sungen sinken die Tiefentestzeiten ab (siehe Tabelle) und die FPS steigen erwartungsgem\active@dq  \dq@prtct{a}\active@dq  \dq@prtct{s} an, mit einer Ausnahme bei der 2432x1440 Aufl\active@dq  \dq@prtct{o}sung, die trotz ihrer erh\active@dq  \dq@prtct{o}hten Puffergr\active@dq  \dq@prtct{o}\active@dq  \dq@prtct{s}e, etwas besser abschneidet als die Full-HD Aufl\active@dq  \dq@prtct{o}sung.}}{5}{figure.10}\protected@file@percent }
\newlabel{fig:resolution_fps}{{10}{5}{Links: FPS-Vergleich aller SOC-Methoden im Intel-Framework bei Full-HD Aufl"osung, aktiviertem MT, FC und TTC. OOC schneidet mit nur einem Bruchteil der FPS von MOC oder SSE deutlich am schlechtesten ab. Rechts: Kamerafahrt mit unterschiedlichen Tiefenpuffergr"o"sen. Mit niedriger werdenden Aufl"osungen sinken die Tiefentestzeiten ab (siehe Tabelle) und die FPS steigen erwartungsgem"a"s an, mit einer Ausnahme bei der 2432x1440 Aufl"osung, die trotz ihrer erh"ohten Puffergr"o"se, etwas besser abschneidet als die Full-HD Aufl"osung}{figure.10}{}}
\@writefile{toc}{\contentsline {paragraph}{Anmerkung}{5}{section*.2}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{Probleme}{5}{section*.3}\protected@file@percent }
\bibstyle{abbrv}
\bibdata{literatur}
\bibcite{SOCF}{1}
\bibcite{PVS}{2}
\bibcite{HiZ}{3}
\bibcite{MSOC}{4}
\@writefile{lof}{\contentsline {figure}{\numberline {11}{\ignorespaces FPS-Vergleich der OOC-Methode mit einer \active@dq  \dq@prtct{a}quivalenten GPU Implementierung, die mit durchschnittlich 43 FPS gegen\active@dq  \dq@prtct{u}ber den 5.4 FPS der OOC-Methode etwa 8x so schnell ist.}}{6}{figure.11}\protected@file@percent }
\newlabel{fig:mesa_gpu}{{11}{6}{FPS-Vergleich der OOC-Methode mit einer "aquivalenten GPU Implementierung, die mit durchschnittlich 43 FPS gegen"uber den 5.4 FPS der OOC-Methode etwa 8x so schnell ist}{figure.11}{}}
\@writefile{toc}{\contentsline {section}{\numberline {5}Fazit}{6}{section.5}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{Future Work}{6}{section*.4}\protected@file@percent }
